
fun min(a,b) return if a<b then a else b;
fun max(a,b) return if a>b then a else b;

fun clip(value,low,high){
    return min(max(low,value),high);
}

fun change(x):bool {
    mem pre_x;
    val v:bool = pre_x!=x;
    pre_x = x;
    return v;
}

fun abs(x) return if x<0 then -x else x;

fun near_zero(x) : bool return abs(x)<1e-12;

fun samplerate() return 44100;
fun PI() return 3.141592653589793;

fun dcblock(x0){
  mem x1,y1;
  val y0 = x0-x1+y1*0.995;
  x1,y1 = x0,y0;
  return y0;
}

fun thermal() return 1/1.22070313;

fun moog_step(input, resFixed, tune,output):real {
    mem tw0,tw1,tw2;
    mem dw0,dw1,dw2,dw3;

    val i0 = input - resFixed * output;
    val w0 = dw0 + tune * (tanh(i0*thermal()) - tw0);

    tw0 = tanh(w0*thermal());
    val w1 = dw1 + tune * tw0 -  tw1;

    tw1 = tanh(w1*thermal());
    val w2 = dw2 + tune * tw1 - tw2;

    tw2 = tanh(w2*thermal());
    val w3 = dw3 + tune * tw2 - tanh(dw3*thermal());

    dw0 = w0;
    dw1 = w1;
    dw2 = w2;
    dw3 = w3;
    return w3;
}

fun moog(input:real, cut:real, res:real):real{
    mem resFixed;
    mem tune;

    if(change(cut) || change(res)){
        // clips the inputs to the valid range
        res = clip(res,0,1);
        cut = clip(cut,1,samplerate());

        val fc = cut/samplerate();
        val x_2 = fc/2;
        val x2 = fc*fc;
        val x3 = fc*x2;
        // Frequency & amplitude correction
        val fcr = 1.8730 * x3 + 0.4955 * x2 - 0.6490 * fc + 0.9988;

        // Resonance compensation
        val acr = -3.9364 * x2 + 1.8409 * fc + 0.9968;

        // Normal scaled impulse invariant transformed one-pole filter; exp() models resonance
        tune = (1.0 - exp(-((2*PI())*x_2*fcr))) / thermal();

        resFixed = 4*res*acr;
    }

    // 2x oversampling
    val x0 = filter:moog_step(input, resFixed, tune,dx1);
    val x1 = filter:moog_step(input, resFixed, tune,x0);
    mem dx1 = x1;
    return (x0+x1)/2;
}

// Main process function
fun process(freq,pw,wave:int,cut,res){
  mem m:int;
  mem rate;
  mem phase;
  mem p;
  mem frequency;
  mem state_triang;
  mem state_pulse;
  mem state_saw;
  mem triang;
  mem pre_wave:int;
  mem output;

  val fixed_frequency = 0;
  if(wave != pre_wave && abs(output) < 0.05) {
    pre_wave = wave;
  }
  if(pre_wave == 0 || pre_wave == 2) {
    fixed_frequency = freq;
  }
  else {
    fixed_frequency = freq / 2;
  }
  // Updates the parameters if the frequency changed
  if(frequency != fixed_frequency) {
    frequency = fixed_frequency;
    p = samplerate() / frequency;
    rate = PI() / p;
    val maxHarmonics = floor(0.5 * p);
    m = 2 * maxHarmonics + 1;
  }
  // Generates a shifted version of the phase
  val shift05 = 0.5 + pw * 0.49;
  val shift = phase + shift05 * PI();
  if(shift > PI()) {
    shift = shift - PI();
  }
  // Generates the first pulse train
  val denominator1 = sin(phase);
  val tmp1 = 0;
  if(near_zero(denominator1)) {
    tmp1 = 1;
  }
  else {
    tmp1 = sin(m * phase);
    tmp1 =  tmp1 / (m * denominator1);
  }
  // Generates the second pulse train
  val denominator2 = sin(shift);
  val tmp2 = 0;
  if(near_zero(denominator2)) {
    tmp2 = 1;
  }
  else {
    tmp2 = sin(m * shift);
    tmp2 = tmp2 / (m * denominator2);
  }
  // Updates the phase
  phase = phase + rate;
  if(phase > PI()) {
    phase = phase - PI();
  }

  // Calculates the waveforms based on the pulse trains
  state_pulse = clip(state_pulse * 0.9999 + tmp1 - tmp2, -1, 1);
  state_saw = clip(state_saw * 0.9999 + (tmp1 + tmp2  - 2 / p)/shift05/2,-1,1);
  state_triang = clip(state_triang * 0.9999 + 2 * state_pulse/p,-1,1);

  // Select the wave to output
  if(pre_wave == 0) {
    output = state_pulse;
  }
  else if(pre_wave == 1) {
    output = state_saw;
  }
  else if(pre_wave == 2) {
    output = 2*state_triang;
  }
  return dcblock(moog(output,cut,res));
}


mem pitch = 400;
mem pw = 0.3;
mem wave:int = 0;
mem cut = 0;
mem res = 0;

val n:int = 0;
while(n<44100){
  val kk = x:process(pitch,pw,wave,cut,res);
  n=n+1;
}

return 0;
