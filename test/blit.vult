
fun min(a,b) return if a<b then a else b;
fun max(a,b) return if a>b then a else b;

fun clip(value,low,high){
    return min(max(low,value),high);
}

fun abs(x) return if x<0 then -x else x;

fun near_zero(x) : bool return abs(x)<1e-12;

fun samplerate() return 44100;
fun PI() return 3.141592653589793;

fun dcblock(x0){
  mem x1,y1;
  val y0 = x0-x1+y1*0.995;
  x1,y1 = x0,y0;
  return y0;
}

// Initialization function
fun init(){
  mem m:int = 0;
  mem rate = 0;
  mem phase = 0;
  mem p = 0;
  mem frequency = 0;
  mem state_triang = 0;
  mem state_pulse = 0;
  mem state_saw = 0;
  mem triang = 0;
  mem pre_wave:int = 0;
  mem output = 0;
  dc:dcblock(0);
}

// Main process function
fun process(freq,pw,wave:int){
  mem m:int;
  mem rate;
  mem phase;
  mem p;
  mem frequency;
  mem state_triang;
  mem state_pulse;
  mem state_saw;
  mem triang;
  mem pre_wave:int;
  mem output;

  val fixed_frequency = 0;
  if(wave != pre_wave && abs(output) < 0.05) {
    pre_wave = wave;
  }
  if(pre_wave == 0 || pre_wave == 2) {
    fixed_frequency = freq;
  }
  else {
    fixed_frequency = freq / 2;
  }
  // Updates the parameters if the frequency changed
  if(frequency != fixed_frequency) {
    frequency = fixed_frequency;
    p = samplerate() / frequency;
    rate = PI() / p;
    val maxHarmonics = floor(0.5 * p);
    m = 2 * maxHarmonics + 1;
  }
  // Generates a shifted version of the phase
  val shift05 = 0.5 + pw * 0.49;
  val shift = phase + shift05 * PI();
  if(shift > PI()) {
    shift = shift - PI();
  }
  // Generates the first pulse train
  val denominator1 = sin(phase);
  val tmp1 = 0;
  if(near_zero(denominator1)) {
    tmp1 = 1;
  }
  else {
    tmp1 = sin(m * phase);
    tmp1 =  tmp1 / (m * denominator1);
  }
  // Generates the second pulse train
  val denominator2 = sin(shift);
  val tmp2 = 0;
  if(near_zero(denominator2)) {
    tmp2 = 1;
  }
  else {
    tmp2 = sin(m * shift);
    tmp2 = tmp2 / (m * denominator2);
  }
  // Updates the phase
  phase = phase + rate;
  if(phase > PI()) {
    phase = phase - PI();
  }

  // Calculates the waveforms based on the pulse trains
  state_pulse = clip(state_pulse * 0.9999 + tmp1 - tmp2, -1, 1);
  state_saw = clip(state_saw * 0.9999 + (tmp1 + tmp2  - 2 / p)/shift05/2,-1,1);
  state_triang = clip(state_triang * 0.9999 + 2 * state_pulse/p,-1,1);

  // Select the wave to output
  if(pre_wave == 0) {
    output = state_pulse;
  }
  else if(pre_wave == 1) {
    output = state_saw;
  }
  else if(pre_wave == 2) {
    output = 2*state_triang;
  }
  return dc:dcblock(output);
}


mem pitch = 400;
mem pw = 0.3;
mem wave:int = 0;

x:init();

val n:int = 0;
while(n<44100){
  val kk = x:process(pitch,pw,wave);
  n=n+1;
}
