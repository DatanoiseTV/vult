
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#ifndef SHORT_DELAY_H
#define SHORT_DELAY_H
#include <stdint.h>
#include <math.h>
#include "vultin.h"
#include "short_delay.tables.h"

static_inline float Saturate_tanh_table_raw_c0(int index){
   return Saturate_tanh_table_c0[index];
};

static_inline float Saturate_tanh_table_raw_c1(int index){
   return Saturate_tanh_table_c1[index];
};

static_inline float Saturate_tanh_table_raw_c2(int index){
   return Saturate_tanh_table_c2[index];
};

static_inline float Saturate_tanh_table(float x){
   int index;
   index = int_clip(float_to_int((5.f * (24.f + x))),0,240);
   return (float_wrap_array(Saturate_tanh_table_c0)[index] + (x * (float_wrap_array(Saturate_tanh_table_c1)[index] + (x * float_wrap_array(Saturate_tanh_table_c2)[index]))));
}

static_inline float Saturate_process(float x){
   return Saturate_tanh_table(x);
};

static_inline void Saturate_noteOn(int note, int velocity, int channel){
}

static_inline void Saturate_noteOff(int note, int channel){
}

static_inline void Saturate_controlChange(int control, int value, int channel){
}

static_inline void Saturate_default(){
}

typedef struct Short_delay__ctx_type_0 {
   float x4;
   float x3;
   float x2;
} Short_delay__ctx_type_0;

typedef Short_delay__ctx_type_0 Short_delay_soft_type;

void Short_delay__ctx_type_0_init(Short_delay__ctx_type_0 &_output_);

static_inline void Short_delay_soft_init(Short_delay__ctx_type_0 &_output_){
   Short_delay__ctx_type_0_init(_output_);
   return ;
}

float Short_delay_soft(Short_delay__ctx_type_0 &_ctx, float x1);

typedef struct Short_delay__ctx_type_1 {
   int write_pos;
   float buffer[22050];
} Short_delay__ctx_type_1;

typedef Short_delay__ctx_type_1 Short_delay_do_type;

void Short_delay__ctx_type_1_init(Short_delay__ctx_type_1 &_output_);

static_inline void Short_delay_do_init(Short_delay__ctx_type_1 &_output_){
   Short_delay__ctx_type_1_init(_output_);
   return ;
}

float Short_delay_do(Short_delay__ctx_type_1 &_ctx, float x, float time, float feedback);

typedef struct Short_delay__ctx_type_2 {
   Short_delay__ctx_type_0 _inst9;
   Short_delay__ctx_type_1 _inst10;
} Short_delay__ctx_type_2;

typedef Short_delay__ctx_type_2 Short_delay_process_type;

void Short_delay__ctx_type_2_init(Short_delay__ctx_type_2 &_output_);

static_inline void Short_delay_process_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

static_inline float Short_delay_process(Short_delay__ctx_type_2 &_ctx, float x, float time, float feedback){
   return Short_delay_do(_ctx._inst10,x,Short_delay_soft(_ctx._inst9,time),feedback);
};

typedef Short_delay__ctx_type_2 Short_delay_noteOn_type;

static_inline void Short_delay_noteOn_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

static_inline void Short_delay_noteOn(Short_delay__ctx_type_2 &_ctx, int note, int velocity, int channel){
}

typedef Short_delay__ctx_type_2 Short_delay_noteOff_type;

static_inline void Short_delay_noteOff_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

static_inline void Short_delay_noteOff(Short_delay__ctx_type_2 &_ctx, int note, int channel){
}

typedef Short_delay__ctx_type_2 Short_delay_controlChange_type;

static_inline void Short_delay_controlChange_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

static_inline void Short_delay_controlChange(Short_delay__ctx_type_2 &_ctx, int control, int value, int channel){
}

typedef Short_delay__ctx_type_2 Short_delay_default_type;

static_inline void Short_delay_default_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

static_inline void Short_delay_default(Short_delay__ctx_type_2 &_ctx){
}



#endif // SHORT_DELAY_H
