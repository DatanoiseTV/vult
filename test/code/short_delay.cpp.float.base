
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "short_delay.h"

void Short_delay__ctx_type_0_init(Short_delay__ctx_type_0 &_output_){
   Short_delay__ctx_type_0 _ctx;
   _ctx.x4 = 0.0000f;
   _ctx.x3 = 0.0000f;
   _ctx.x2 = 0.0000f;
   _output_ = _ctx;
   return ;
}

void Short_delay_soft_init(Short_delay__ctx_type_0 &_output_){
   Short_delay__ctx_type_0_init(_output_);
   return ;
}

float Short_delay_soft(Short_delay__ctx_type_0 &_ctx, float x1){
   float o;
   o = ((x1 + _ctx.x2 + _ctx.x3 + _ctx.x4) * 0.2500f);
   float _tmp_9_0;
   _tmp_9_0 = x1;
   float _tmp_9_1;
   _tmp_9_1 = _ctx.x2;
   float _tmp_9_2;
   _tmp_9_2 = _ctx.x3;
   _ctx.x2 = _tmp_9_0;
   _ctx.x3 = _tmp_9_1;
   _ctx.x4 = _tmp_9_2;
   return o;
}

void Short_delay__ctx_type_1_init(Short_delay__ctx_type_1 &_output_){
   Short_delay__ctx_type_1 _ctx;
   _ctx.write_pos = 0;
   float_init_array(22050,0.0000f,_ctx.buffer);
   _output_ = _ctx;
   return ;
}

void Short_delay_do_init(Short_delay__ctx_type_1 &_output_){
   Short_delay__ctx_type_1_init(_output_);
   return ;
}

float Short_delay_do(Short_delay__ctx_type_1 &_ctx, float x, float time, float feedback){
   time = float_clip(time,0.0000f,1.0000f);
   feedback = float_clip(feedback,0.0000f,1.0000f);
   float index_r;
   index_r = (22050.0000f * time);
   int index_i;
   index_i = float_to_int(floorf(index_r));
   int delta;
   delta = (_ctx.write_pos + (- index_i));
   int read_pos;
   uint8_t _cond_10;
   _cond_10 = (delta < 0);
   if(_cond_10){ read_pos = (22050 + delta); }
   else
   { read_pos = delta; }
   float decimal;
   decimal = (index_r + (- int_to_float(index_i)));
   float x1;
   x1 = float_get(_ctx.buffer,read_pos);
   float x2;
   x2 = float_get(_ctx.buffer,((read_pos + 1) % 22050));
   float ret;
   ret = (((x2 + (- x1)) * decimal) + x1);
   _ctx.write_pos = ((_ctx.write_pos + 1) % 22050);
   float_set(_ctx.buffer,_ctx.write_pos,tanhf((x + (feedback * ret))));
   return ret;
}

void Short_delay__ctx_type_2_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2 _ctx;
   Short_delay__ctx_type_1_init(_ctx._inst4);
   Short_delay__ctx_type_0_init(_ctx._inst3);
   _output_ = _ctx;
   return ;
}

void Short_delay_process_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

float Short_delay_process(Short_delay__ctx_type_2 &_ctx, float x, float time, float feedback){
   return Short_delay_do(_ctx._inst4,x,Short_delay_soft(_ctx._inst3,time),feedback);
}

void Short_delay_noteOn_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

void Short_delay_noteOn(Short_delay__ctx_type_2 &_ctx, int note, int velocity, int channel){
}

void Short_delay_noteOff_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

void Short_delay_noteOff(Short_delay__ctx_type_2 &_ctx, int note, int channel){
}

void Short_delay_controlChange_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

void Short_delay_controlChange(Short_delay__ctx_type_2 &_ctx, int control, int value, int channel){
}

void Short_delay_default_init(Short_delay__ctx_type_2 &_output_){
   Short_delay__ctx_type_2_init(_output_);
   return ;
}

void Short_delay_default(Short_delay__ctx_type_2 &_ctx){
}


