
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "blit.h"

void Util__ctx_type_3_init(Util__ctx_type_3 &_output_){
   Util__ctx_type_3 _ctx;
   _ctx.y1 = 0.f;
   _ctx.x1 = 0.f;
   _output_ = _ctx;
   return ;
}

float Util_dcblock(Util__ctx_type_3 &_ctx, float x0){
   float y0;
   y0 = (x0 + (- _ctx.x1) + (0.995f * _ctx.y1));
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

void Phase__ctx_type_0_init(Phase__ctx_type_0 &_output_){
   Phase__ctx_type_0 _ctx;
   _ctx.rate = 0.f;
   _ctx.phase = 0.f;
   Util__ctx_type_0_init(_ctx._inst22);
   Util__ctx_type_1_init(_ctx._inst20);
   Phase_default(_ctx);
   _output_ = _ctx;
   return ;
}

float Phase_process(Phase__ctx_type_0 &_ctx, float cv, float reset){
   if(Util_change(_ctx._inst20,cv)){
      _ctx.rate = Util_cvToRate_1024(cv);
   }
   if(Util_edge(_ctx._inst22,(reset > 0.5f))){
      _ctx.phase = 0.f;
   }
   else
   {
      _ctx.phase = (_ctx.phase + _ctx.rate);
   }
   if(_ctx.phase > 1024.f){
      _ctx.phase = (-1024.f + _ctx.phase);
   }
   return (0.0009766f * _ctx.phase);
}

void Blit__ctx_type_0_init(Blit__ctx_type_0 &_output_){
   Blit__ctx_type_0 _ctx;
   _ctx.scale = 0.f;
   _ctx.m = 0;
   Util__ctx_type_1_init(_ctx._inst29);
   Blit_pulse_start(_ctx);
   _output_ = _ctx;
   return ;
}

float Blit_pulse_train(Blit__ctx_type_0 &_ctx, float cv, float phase){
   if(Util_change(_ctx._inst29,cv)){
      _ctx.m = (1 + (float_to_int(Util_cvToperiod(cv)) << 1));
      _ctx.scale = (2.f * Util_cvToperiod(cv));
   }
   float pi_phase;
   pi_phase = (0.5f * phase);
   float denominator;
   denominator = Tables_nsine(pi_phase);
   float out;
   out = 0.f;
   if(denominator <= 1e-07f){
      out = 1.f;
   }
   else
   {
      float m_phase;
      m_phase = fmodf((pi_phase * int_to_float(_ctx.m)),1.f);
      float numerator;
      numerator = Tables_nsine(m_phase);
      out = (numerator / (_ctx.scale * denominator));
   }
   return out;
}

void Blit__ctx_type_1_init(Blit__ctx_type_1 &_output_){
   Blit__ctx_type_1 _ctx;
   _ctx.state_saw = 0.f;
   _ctx.state_pulse = 0.f;
   _ctx.rate = 0.f;
   _ctx.output = 0.f;
   Util__ctx_type_3_init(_ctx._inst45);
   Blit__ctx_type_0_init(_ctx._inst42);
   Blit__ctx_type_0_init(_ctx._inst41);
   Phase__ctx_type_0_init(_ctx._inst39);
   Util__ctx_type_1_init(_ctx._inst37);
   Blit_init(_ctx);
   _output_ = _ctx;
   return ;
}

float Blit_osc_blit(Blit__ctx_type_1 &_ctx, float cv, float pw, float wave){
   float fixed_cv;
   fixed_cv = 0.f;
   if(wave < 1.f){
      fixed_cv = cv;
   }
   else
   {
      fixed_cv = (-0.1f + cv);
   }
   if(Util_change(_ctx._inst37,fixed_cv)){
      _ctx.rate = Util_cvToRate(fixed_cv);
   }
   float phase;
   phase = Phase_process(_ctx._inst39,fixed_cv,0.f);
   float shift05;
   shift05 = (0.5f + (0.49f * pw));
   float shift;
   shift = (phase + shift05);
   if(shift > 1.f){
      shift = (-1.f + shift);
   }
   float pulse1;
   pulse1 = Blit_pulse_train(_ctx._inst41,fixed_cv,phase);
   float pulse2;
   pulse2 = Blit_pulse_train(_ctx._inst42,fixed_cv,shift);
   _ctx.state_pulse = (pulse1 + (- pulse2) + (0.9995f * _ctx.state_pulse));
   _ctx.state_saw = ((0.5f * ((pulse1 + pulse2 + (-2.f * _ctx.rate)) / shift05)) + (0.9995f * _ctx.state_saw));
   if(wave < 1.f){
      _ctx.output = _ctx.state_pulse;
   }
   else
   {
      _ctx.output = (2.f * _ctx.state_saw);
   }
   _ctx.output = Util_dcblock(_ctx._inst45,_ctx.output);
   return _ctx.output;
}


