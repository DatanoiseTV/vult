
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "monocv.h"

void Util__ctx_type_3_init(Util__ctx_type_3 &_output_){
   Util__ctx_type_3 _ctx;
   _ctx.y1 = 0x0 /* 0.000000 */;
   _ctx.x1 = 0x0 /* 0.000000 */;
   _output_ = _ctx;
   return ;
}

fix16_t Util_dcblock(Util__ctx_type_3 &_ctx, fix16_t x0){
   fix16_t y0;
   y0 = (x0 + (- _ctx.x1) + fix_mul(0xfeb8 /* 0.995000 */,_ctx.y1));
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

void Monocv__ctx_type_0_init(Monocv__ctx_type_0 &_output_){
   Monocv__ctx_type_0 _ctx;
   _ctx.pre = 0;
   int_init_array(4,0,_ctx.notes);
   _ctx.count = 0;
   _output_ = _ctx;
   return ;
}

int Monocv_mono_noteOn(Monocv__ctx_type_0 &_ctx, int n){
   if(_ctx.count < 4){
      int_set(_ctx.notes,_ctx.count,n);
      _ctx.pre = n;
      if(_ctx.count < 4){
         _ctx.count = (1 + _ctx.count);
      }
   }
   return _ctx.pre;
}

int Monocv_mono_noteOff(Monocv__ctx_type_0 &_ctx, int n){
   uint8_t found;
   found = false;
   int pos;
   int i;
   i = 0;
   if(_ctx.count == 0){
      return _ctx.pre;
   }
   while((i < 4) && bool_not(found)){
      if(int_get(_ctx.notes,i) == n){
         pos = i;
         found = true;
      }
      i = (1 + i);
   }
   if(found){
      int k;
      k = (1 + pos);
      while(k < 4){
         int_set(_ctx.notes,((-1) + k),int_get(_ctx.notes,k));
         k = (1 + k);
      }
      if(found && (_ctx.count > 0)){
         _ctx.count = ((-1) + _ctx.count);
         _ctx.pre = int_get(_ctx.notes,((-1) + _ctx.count));
      }
   }
   return _ctx.pre;
}

void Monocv__ctx_type_1_init(Monocv__ctx_type_1 &_output_){
   Monocv__ctx_type_1 _ctx;
   _ctx.vel = 0x0 /* 0.000000 */;
   _ctx.process_ret_2 = 0x0 /* 0.000000 */;
   _ctx.process_ret_1 = 0x0 /* 0.000000 */;
   _ctx.process_ret_0 = 0x0 /* 0.000000 */;
   Monocv__ctx_type_0_init(_ctx.notes);
   _ctx.gate = 0x0 /* 0.000000 */;
   _ctx.cv = 0x0 /* 0.000000 */;
   _ctx.channel_in = 0;
   _ctx.active_note = 0;
   Util__ctx_type_1_init(_ctx._inst159);
   _output_ = _ctx;
   return ;
}

void Monocv_process(Monocv__ctx_type_1 &_ctx, int c){
   _ctx.channel_in = c;
   if(Monocv_mono_isGateOn(_ctx.notes)){
      _ctx.gate = _ctx.vel;
   }
   else
   {
      _ctx.gate = 0x0 /* 0.000000 */;
   }
   fix16_t note;
   note = int_to_fix(_ctx.active_note);
   if(Util_change(_ctx._inst159,note)){
      _ctx.cv = Util_pitchToCv(note);
   }
   _ctx.process_ret_0 = _ctx.cv;
   _ctx.process_ret_1 = _ctx.vel;
   _ctx.process_ret_2 = _ctx.gate;
   return ;
}

void Monocv_noteOn(Monocv__ctx_type_1 &_ctx, int note, int velocity, int channel){
   if(_ctx.channel_in == channel){
      if(velocity > 0){
         _ctx.active_note = Monocv_mono_noteOn(_ctx.notes,note);
         _ctx.vel = fix_mul(0x204 /* 0.007874 */,int_to_fix(velocity));
      }
      else
      {
         _ctx.active_note = Monocv_mono_noteOff(_ctx.notes,note);
      }
   }
}


